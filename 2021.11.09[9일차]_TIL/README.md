# 2021.11.09 [9일차]

오늘은 지난주부터 이어온 많은 예습을 조원과 러버덕 하고 강사님과의 질의응답을 통해 모르던 부분을 보강하고 프로토타입에 대한 수업을 들을 수 있었다.  
12강부터 20강까지의 내용이 대부분 프로토타입을 설명하기 위한 단원이였으며 이를 통해 프로토타입이 JS에 있어 아주 중요하고 핵심이라는것을 알았다.  
프로토타입에 대한 공부를 추가적으로 최대한 이해 할 수 있도록 해야겠다.

## 공부한 내용

- 전역변수의 문제점
- 모듈패턴을 통한 캡슐화가 다른 객체지향언어의 캡슐화와 다른점
- 클린코드의 기초  
- 일급객체와 중복함수에 대한 설명
- __proto__접근자 프로퍼티는 왜 접근자 프로퍼티인가
- 프로토타입에 대한 설명
- JS에서 this가 가리키는 내용은 맥락에 따라 변함

## 학습 결과물

학습 결과물은 같이 포함된 파일에 동봉되었으며 각 TIL의 목록별 소제목에 링크가 달려있다.

### 강의 학습 현황

\> 러버덕, 질의 응답 수업,  프로그래머스 정렬 문제풀이

## 질의 응답

### 전역변수의 문제점

- 암묵적 결합
- 긴 생명 주기
- 스코프 체인 상에서 종점에 존재
- 네임스페이스 오염

### 모듈패턴(캡슐화)

자바스크립트의 접근제한자는 모두 public이다.  
자바스크립트의 캡슐화는 완전한 캡슐화가 아니다.  
JS는 JS의 방식으로 구현해야한다. JS를 JAVA처럼 쓰려고 하면 안된다. JS는 프로토타입기반의 객체지향언어이다. 프로그래밍 패러다임에 대한 고민을 해볼것

동작은 브라우저밖에 감지못한다. 따라서 개발자는 함수를 만들고 브라우저가 함수를 호출하도록 요청해야한다. 브라우저에게 특정 html요소를 알려주고 해당 요소에 특정 이벤트가 발생하면 미리 만든 함수를 호출하도록 요청하는 방법

클로저 : 면접에서 무조건 물어보는 매우 중요한 주제이다. 정보은닉을 구현한다고 하는데 아직 메타 정보를 다 익히지 않았으므로 이름만 알고 넘어가기

### 클린코드

- 좋은이름 짓기
- 중복 제거하기
- 한번에 하나의 일을 하는 함수 만들도록 노력하기

안티패턴이란 문법적으론 문제가 없으나 논리적으론 안되는것을 말한다.  
코드를 읽는다는것은 문법 뿐 아닌 개발자의 의도를 읽어야 하는 것이다.

### 일급 객체

함수가 일급객체라는것은 그 언어가 함수형 언어라는것이다.  
일급객체 구분법 (매우 중요)

1. 함수를 리턴이 가능하다.
2. 함수를 매개변수로 사용할 수 있다.

고차함수: 함수를 매개변수로 받거나 함수를 리턴하는 함수이다. 함수가 일급객체이기 때문에 가능하다.  
중첩함수를 만드는 이유: 함수가 안에서 두가지 일을 할때 -> 중첩함수로 나눈다.

HTML-> 어트리뷰트  
CSS -> 프로퍼티  
JS -> 프로퍼티 : ( +내부의 어트리뷰트)

### __proto__접근자 프로퍼티

__proto__접근자 프로퍼티를 통해 접근하는것으로 무한루프를 방지할수 있는 이유  
-> __proto__가 데이터 프로퍼티면 별다른 검사없이 할당이 가능해짐 : 자신이 부모의 프로토타입이 되면서 무한루프될 수 있다.

JS의 클래스 = 함수 = 클래스도 일급객체

### 프로토타입

객체의 추상화 -> 객체가 서로 커뮤니케이션한다.  
데이터를 프로퍼티, 행위를 메서드라고한다.

같은 객체를 많이 만들어야 한다면? -> 리터럴 함수보다 생성자 함수가 유리하다.  
생성자 함수는 : 클래스 기반언어의 클래스와 같다.  
함수는 호출하기전엔 어떤 함수인지 알 수 없다 = 함수는 호출방식에 따라 그 종류가 결정된다.  
this또한 호출하는 시점에따라 가리키는 곳이 달라진다.

일반함수 : 전역객체  
생성자 : 인스턴스  
메서드 : 본인을 호출한 객체

JS의 함수는 리턴이 없다면 암묵적으로 리턴을 한다. (일반함수)  
생성자 함수로 사용하면 this에 빈객체를 만든다.(암묵적) -> 프로퍼티를 this에 바인딩한다. -> this를 리턴한다.(암묵적)

## 프로그래머스 문제풀이

### K번째 수 1단계 (정렬)

```js
function solution(array, commands) {
  const answer = [];
  // 주어진 commands에 따라 배열을 자른다.
  for (let i = 0; i < commands.length; i++) {
    const newArr = array.slice(commands[i][0] - 1, commands[i][1]);
    // 정렬
    newArr.sort((x, y) => x - y);
    // commands에 따른 조건에 맞는 위치값을 answer에 push한다
    answer.push(newArr[commands[i][2] - 1]);
  }
  return answer;
}
```

### 가장 큰 수 2단계 (정렬)
```js
function solution(numbers) {
  // Array.sort((x,y)=> x-y) : 오름차순 정렬
  // sort메서드는 x-y가 양수이면 바꾼다
  // 문자열 비교를 해야함
  // map은 조건에 맞춘 배열을 반환한다
  // 뒤 + 앞이 앞+뒤보다 크면 바꿔야함 x = 뒤+앞 y = 앞+뒤
  const answer = numbers.map(el => el+'').sort((x,y)=> (y+x) - (x+y)).join('');
  // 입력값이 모두 0인경우 0을 반환한다.
  return answer.split('0').join('') ? answer : '0';
}
```