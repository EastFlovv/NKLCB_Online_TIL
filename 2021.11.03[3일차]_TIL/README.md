## 2021.11.02 [2일차]


## 공부한 내용


## 학습 결과물
학습 결과물은 같이 포함된 파일에 동봉되었으며 각 TIL의 목록별 소제목에 링크가 달려있다.

### 강의 학습 현황

\> 6~11강 예습

## 6강 데이터 타입

숫자타입은 ECMAScript에 따르면 배정밀도 64비트 부동소수점 형식을 사용한다.  
모든 수는 실수(2, 8, 16진수의 데이터 타입이 없다)이다.  
추가로 Infinity, -Infinity, NaN가 추가로 있고 대소문자를 구별한다.  

문자열 타입은 0개 이상의 16비트 유니코드 문자의 집합으로 전세계 대부분의 문자를 표현 할 수 있다.  
문자열은 따옴표로 감싸서 표현하며 ‘’, “”, ``을 사용 따옴표로 감싸지 않으면 식별자나 토큰으로 인식한다.  
문자열은 변경 불가능한 값 (immutable value)이다.  
템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 태그드 탬플릿 등 편리한 문자열 처리기능을 제공하며 백틱을 사용하여 표현한다.  

- 멀티라인 문자열: 일반 문자열에서는 줄바꿈을 무시한다.  
일반 문자열에서 줄바꿈등의 공백을 표현하려면 백슬래시(\\)로 시작하는 이스케이프 시퀸스를 사용한다.  
하지만 탬플릿 리터럴 내에서는 이스케이프 시퀸스를 사용하지 않고도 줄바꿈을 허용하고 모든 공백도 있는 그대로 적용한다.

- 표현식 삽입: 문자열은 문자열 연산자 +를 이용해 연결한다.  
	+연산자는 피 연산자중 하나이상이 문자열이면 문자열 연결 연산자로 동작한다.  
  그 외의 경우엔 덧셈 연산자로 동작한다,  
	템플릿 리터럴 에서는 표현식 삽입을 통해 간단히 문자열을 삽입 할 수 있다.  
  ${}로 표현식을 감싸 표현식의 결과가 문자가 아니더라도 문자로 강제 변환되어 삽입한다.  

불리언 타입은 논리적 참, 거짓 (true, false)를 나타낸다.  
undefined타입은 undefined하나이다.  
var로 선언한 변수는 암묵적으로 undefiend로 초기화된다.  
undefined는 개발자가 의도적으로 할당하기 위한 값이 아닌 JS엔진이 변수를 초기화 할 때 사용하는 값이다.  

변수에 값이 없음을 나타내고 싶다면 undefined대신 null을 사용해야 한다.  
null타입은 null한개, 대소문자를 구별한다.  
변수에 값이 없음을 의도적으로 명한다. 함수가 유효한 값을 반환 할 수 없는 경우 null을 반환하기도 한다.  

심벌 타입- ES6에 추가된 원시타입이다.  
주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해사용한다.  
심벌 이외의 원시값은 리터럴을 통해 생성하지만, 심벌은 Symbol함수를 통해 생성한다
생성된 심벌 값은 외부로 노출되지 않으며 다른값과는 절대 중복되지 않는 유일무이한 값이다.  


객체 타입
-	JS 데이터 타입은 원시타입, 객체타입으로 구분된다.
-	자바스크립트는 객체 기반언어이며, JS를 이루는 거의 모든 것은 객체이다.

데이터 타입의 필요성
	데이터 타입은 의한 메모리 공간의 확보와 참조를 위해 쓰인다.
-	값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.
-	ECMAScript 사양은 숫자 타입외에는 데이터 타입의 크기를 명시하지 않는다. 데이터 타입에 의한 값의 해석을 한다.

데이터 타입이 필요한 이유
-	값을 저장할 때 확보 해야 할 메모리 공간의 크기를 결정하기 위해
-	값을 참조할 때 한번에 읽어 들일 메모리 공간의 크기를 결정하기 위해
-	메모리에서 읽어들인 2진수를 어떻게 해석해야할지 결정하기 위해

동적 타이핑
JS는 정적타입언어와 달리 변수 선언시 타입을 선언하지 않는다. 따라서 어떤 데이터 타입의 값이라도 자유롭게 할당가능하다.  

자바 스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정 된다. (타입 추론)  
그리고 재할당에 의해 타입은 언제든 동적으로 변할 수 있다. (이러한 특징을 동적 타이핑이라고 한다)  
JS를 정적 타입 언어와 구별하기 위해 동적타입언어라고 부른다.  

변수는 타입을 갖지 않는다. -> 값은 타입을 갖는다. -> 변수에 할당된 값에 의해 변수 타입이 동적으로 결정된다.  

동적 타입 언어의 구조적 단점
- 변수의 값을 확인하기 전에는 타입을 확신할 수 없다.
- JS에서 개발자의 의도와 상관없이 JS Engine에 의해 암묵적으로 타입이 자동으로 변환되기도 한다.
- 따라서 동적타입언어는 유연성은 높지만 신뢰성은 떨어진다.

변수 사용시 주의 사항

- 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.  
- 변수의 유효범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제한다.
- 전역 변수는 최대한 사용을 자제한다.
- 변수 보다 상수를 사용하여 값의 변경을 억제한다.
- 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍 한다.

## 7강 연산자

연산자는 하나이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 수연산등을 수행해 하나의 값을 만든다.  
- 피연산자 : 값으로 평가될 수 있는 표현식
- 피연산자 + 연산자 = 연산자 표현식 : 값으로 평가될 수 있는 표현식
-  연산자 -> 피연산자를 연산하여 새로운 값을 만든다.

### 산술 연산자
피연산자를 대상으로 수학적 계산을 수행한다.  
계산이 불가능한 경우 NaN반환한다. (Not a Number)
이항 산술 연산자 : +, -, *, /, % -> 피연산자의 값이 바뀌지 않고 새 값을 만든다.  
단항 산술연산자 : ++, -- : 피연산자의 값을 바꾼다. (위치에 따라 연산의 순서가 바뀜), + 효과없음, - 음수, 양수 반전  
문자열 연결 연산자 : + 피연산자 중 하나이상이 문자열이라면 문자열 연결 연산자로 동작한다.	이때, 문자열이 아닌 타입들은 암묵적 타입변환을 통해 문자열로 바꾼다. 

### 할당 연산자
=, +=, -=, 8=, /=, %= : 전부 피연산자의 값을 바꾼다.  
할당문은 값으로 평가되는 표현식인 문: 연쇄할당이 가능하다 (let x = c= k = 0)  
비교 연산자: 좌항, 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.  
동등/일치 비교연산자 : 동등비교는 느슨한 비교, 일치 비교는 엄격한 비교이다.  
- ==, != 동등비교 | === ,!== 일치비교
- 동등비교는 암묵적 타입변환을 통해 타입을 일치 시킨후 비교한다.
- 일치비교는 타입과 값이 같아야 true를 반환한다.
- NaN는 자신과 일치하지 않는 유일한 값으로 isNaN()을 통해 NaN인지 판별한다.  

### 대소 관계 비교 연산자
\>, <, >=, <=  
피연산자의 크기를 비교하여 불리언 값을 반환한다.   
삼항 조건 연산자 : 두번째 피연산자, 또는 세번째 피연산자로 평가되는 표현식이다.
```
조건식 ? 조건식 true시 반환값 : 조건식 false시 반환값
```
삼항 조건 연산자 표현식은 값처럼 사용이 가능하지만 if…else처럼 사용이 불가능하다.

### 논리 연산자
우항과 좌항의 피연산자를 논리연산한다.  
!! 논리합(OR), && 논리곱 (AND), ! 부정 (NOT)  
논리 부정 연산자는 언제나 불리언 값을 반환함 만약 피연산자가 불리언이 아니라면 불리언 타입으로 암묵적 변환 한다.  
논리합 논리곱 연산자 표현식의 평가 결과는 불리언 값이 아닐 수 있다.  
논리합 논리곱 연산자 표현식은 언제가 2개의 피연산자중 어느 한쪽으로 평가된다.  

### 쉼표 연산자
쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.  

### 그룹 연산자 ()
소괄호로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다.  

### typeof 연산자
typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.  
typof연산자로 null값을 연산해보면 null이 아닌 object를 반환한다 : JS첫번째 버전의 버그이다. 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다.  
선언 하지 않은 식별자를 typeof로 연산하면 ReferenceError가 발생하지 않고 undefined가 발생한다.  

### 지수 연산자 **
ES7에서 도입, 좌항을 밑으로 우항을 지수로 거듭제곱한다.
이전에는 Math.pow()를 사용했다.  
음수를 거듭제곱하기위해선 괄호로 묶어야한다.
 ```js
 (-5) ** 2 // 25
 ```

### 연산자의 부수효과 (side effect)
다른 코드에 영향을 주는 부수효과가 있는 연산자
- 할당연산자(=)
- 증감연산자 (++/--)
- delete 연산자


## 8강 제어문
제어문은 조건에 따라 코드 블록을 실행 하거나 반복할 때 사용한다.  
일반적으로 코드는 위에서 아래로 실행되나 제어문을 사용시 코드의 실행 흐름을 인위적으로 제어 할 수 있다.  
제어문은 코드의 흐름을 이해하기 어렵게 만들어 가독성을 해치는 단점이 있다.  
`forEach`, `map`, `filter`, `reduce`와 같은 고차함수를 통해 복잡성을 낮추려고 노력한다.  

### 블록문 : 0개 이상의 문을 {}로 묶은 것
자바스크립트는 블록문을 하나의 실행 단위로 취급한다.  
블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.  

### 조건문
조건문은 주어진 조건식의 평가 결과에 따라 코드블록의 실행을 결정한다.  
조건식은 불리언 값으로 평가 될 수 있는 표현식이다.  
JS는 `if…else`문과 `switch`문을 제공한다.  

### if…else문
주어진 조건식의 평가에 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다.
```js
if(조건식){
  // 조건식이 참일때
}else{
  // 조건식이 거짓일때
}
```
`if`문의 조건식이 불리언 값이 아닌 값으로 평가된다면 JS엔진에 의해 암묵적 변환되어 실행할 코드블록을 결정한다.  
`else if`문과 `else`는 옵션이다. `if`와 `else`는 한번만 사용 하고 `else if`는 여러 번 사용 가능하다.  
대부분의 `if…else`문은 삼항 조건 연산자로 바꿔 쓸 수 있다.  
조건에 따라 단순히 값을 결정하여 변수에 할당 하는 경우는 `if…else`문보다 삼항 조건 연산자를 사용하는 편이 가독성에 좋다. 하지만 조건에 따라 실행 되어야 할 내용이 복잡하여 여러줄의 문이 필요하다면 `if…else`문이 더 가독성이 좋다.

### switch문
주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 `case`문으로 실행 흐름을 옮긴다.
`switch`문의 표현식과 일치하는 `case`문이 없다면 `default`문으로 이동한다.  
`if…else`문이 논리적 참 거짓으로 실행할 코드를 결정한다면 `switch`문은 참 거짓보다 다양한 상황에 따라 실행할 코드블록을 결정할 때 사용한다.  
`break`문이 없다면 `case`문으로 이동한 실행 흐름이 자신의 코드 아래쪽에 있는 모든 코드를 실행한다 이를 폴스루라고 한다.   

### 반복문
반복문은 조건식의 평가 결과가 참인경우 코드블록을 실행한다.  
그 후 조건식을 다시 평가하여 여전히 참인경우 코드블록을 다시 실행한다 이는 조건식이 거짓일때 까지 반복한다.  
JS는 `for`, `while`, `do…while`문을 제공한다

### for문
`for`문은 조건식이 거짓으로 평가될 때 까지 코드블록을 반복 실행 한다.  
`for`문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다.  
단, 어떤 식도 선언하지 않으면 무한 루프가 된다.

### while문
`while`문은 주어진 조건식의 평가가 참이면 코드블록을 계속해서 반복실행한다.  
`for`문은 반복 횟수가 명확할 때, `while`은 반복 횟수가 불명확 할 때 주로 사용한다.  
조건식의 평가가 언제나 참이면 무한루프한다.  
무한 루프에서 탈출 하기 위해서는 `if`문으로 탈출 조건을 만들고 `break`문으로 코드블록을 탈출한다.  

### do while문 
`do…while`문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드블록은 무조건 한번 이상 실행된다.

### Break문
`break`문은 코드 블록을 탈출한다. 정확한 표현으로는 레이블문, 반복문 또는 switch문의 코드 블록을 탈출한다.  
레이블 문은 식별자가 붙은 문을 말한다.
레이블문은 프로그램의 실행 순서를 제어하는데 사용한다 사실 `switch`문의 `case`문과 `default`문도 레이블 문이다.  
레이블 문을 탈풀하려면 `break`문에 레이블 식별자를 지정한다.  

레이블문은 중첩된 `for`문을 탈출할 때 유용하지만 그 외의 경우 일반적으로 권장하지 않는다.  
레이블 문을 사용하면 프로그램의 흐름이 복잡해져 가독성이 나빠지고 오류를 일으킬 가능성이 높아지기 때문이다.  

### continue문
`continue`문은 반복문의 코드블록 실행을 현 시점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.  



## 9장 타입변환과 단축평가
### 타입변환이란?
개발자가 의도적으로 값의 타입을 변환 하는 것은 명시적 타입변환 또는 타입캐스팅이라고 한다.  
개발자의 의도와 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환 되기도 한다 이를 암묵적 타입변환 또는 강제 타입변환이라고 한다.

원시값은 변경 불가능한 값이므로 변경 할 수 없다 : 타입변환이란 기존의 원시값을 이용해 새 원시값을 생성하는 것이다. 암묵적 타입변환이 일어날때 JS엔진은 표현식을 에러없이 평가하기 위해 피연산자 값을 암묵적 타입변환해 단 한번 사용하고 버린다.

자신이 작성한 코드에 암묵적 타입변환이 일어나는지 일어난다면 어떤 타입의 어떤 값으로 변하는지 변환된 값으로 표현식이 어떻게 평가될지 예측 가능해야한다.  
명시적 타입변환보다 암묵적 타입변환이 가독성 측면에서 더 좋을 수 있다.

### 암묵적 타입변환
### 문자열 타입변환
JS엔진은 문자열 연결 연산자 표현식을 평가하기 위해 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열타입으로 암묵적 타입변환한다

### 숫자 타입변환
산술 연산자의 모든 피연산자는 문맥상 숫자타입이여야 하므로 피연산자를 숫자타입으로 암묵적 타입변환 한다.
이때 피연산자를 숫자타입으로 나타낼 수 없는경우 산술 연산을 수행 할 수 없으므로 표현식의 평가는 NaN이 된다

비교 연산에서도 피연산자의 크기를 비교하므로 모든 피연산자는 문맥상 숫자타입으로 암묵적 타입변환된다.  
+단항 연산자를 통해 숫자타입으로 암묵적 타입변환을 실행 할 수 있다.  
빈문자열 빈배열 null, false는 0으로 true는 1로 변환된다.  
객체 빈배열이 아닌 배열 undefined는 변환되지 않아 NaN가 된다.  


### 불리언 타입 변환
if문이나 for문 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언값, 즉 논리적 참/거짓으로 평가되어야 하는 표현식이다.
JS엔진은 불리언 타입이 아닌 값은 Truthy삾 또는 Fasly값으로 구분한다

### 명시적 타입변환  
표준 빌트인 생성자 함수를 new연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 그리고 암묵적 타입변환을 이용한 방법이 있다.

- 문자열 타입으로 변환  
String함수를 new 없이 호출한다.  
Object.prototype.toString메서드를 사용한다.  
문자열 연결 연산자를 사용하는 방법한다.  

- 숫자타입으로 변환  
Number생성자 함수를 new없이 호출한다.  
parseInt, parseFloat함수를 사용한다.  
+단항 산술연산자를 사용한다.  
*산술연산자를 이용한다.  

- 불리언 타입으로 변환
boolean생성자 함수를 new없이 호출한다.  
! 부정논리 연산자를 두번 사용한다.  

### 단축평가
논리 연산자를 사용한 단축평가  

논리곱(&&) 연산자 두개의 연산자가 모두 true일 때 true 반환한다.  
->논리 연산의 결과를 결정하는 두번째 피연산자를 반환한다.	논리합 연산자도 동일하게 동작한다.

논리합, 논리곱 연산자가 논리 연산의 결과를 타입변환하지 않고 그대로 반환하는것을 단축평가라고 한다. 단축평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가과정을 생락하는것을 말한다.

true일 때 무언가를 해야한다면 논리곱연산자 표현식으로 if문을 대체할 수 있다.  
falsy로 무언가를 해야한다면 논리합 연산자로 if문 대체할 수 있다.  
삼항조건연산자는 if…else를 대체할 수 있다.  


### 옵셔널 체이닝 연산자
ES11에서 도입된 옵셔널 체이닝연산자는 `?.`의 모습을 한다.  
좌항의 피연산자가 null, undefined라면 undefined를 반환하고 그렇지 않다면 우항의 참조를 이어간다.  
하지만 좌항의 피연산자가 flasy값 이여도 null이나 undefined가 아니라면 우항참조를 이어간다.  

### Null 병합 연산자
ES11에서 도입된 null병합 연산자 ??는 좌항의 피연산자가 null또는 undefined라면 우항을 반환하고 아니라면 좌항의 피연산자를 반환한다.  
하지만 좌항의 피연산자가 flasy값 이여도 null이나 undefined가 아니라면 좌항의 피연산자를 반환한다.  

## 10강 객체 리터럴
JS는 객체기반 프로그래밍 언어이며 JS를 구성하는 거의 모든 것은 객체이다.  
원시값을 제외한 나머지는 모두 객체이며 객체는 복합적 자료구조이다.  
원시타입의 값은 변경 불가능한 값이지만 객체는 변경 가능한 값이다.  

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.  
자바스크립트에서 사용할 수 있는 모든값은 프로퍼티 값이 될 수 있다.  
함수도 프로퍼티값으로 사용가능 , 프로퍼티값이 함수일 경우 일반 함수와 구분하기위해 매서드라고 부른다.  

JS는 클래스 기반의 객체지향 언어와 달리 다양한 객체 생성방법을 지원한다. 
- 객체 리터럴
- Object생성자 함수
- 생성자 함수
- object.creat메서드
- 클래스(ES6)

### 객체 리터럴
객체 리터럴은 중괄호 안에 0개 이상의 프로퍼티를 정의한다.  
객체 리터럴의 중괄호는 코드블록을 의미하지 않으므로 객체 리터럴의 끝에는 세미콜론을 붙인다.  
객체 리터럴 외의 객체 생성 방식은 모두 함수를 사용한다.  

### 프로퍼티
객체는 프로퍼티의 집합 : 프로퍼티는 키와 값으로 구성된다.
프로퍼티의 나열시 쉼표로 구분한다.    
- 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값  
- 프로퍼티 값 : JS에서 사용할 수 있는 모든 값  

프로퍼티 키의 이름이 JS에서 사용가능한 유효한 이름인 경우 따옴표를 생략할 수 있다.  
문자열 또는 문자열로 평가 할 수 잇는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. 이때 프로퍼티 키를 대괄호로 묶어야한다.  
프로퍼티키에 심벌이나 문자열 외의 값을 쓰면 암묵적 타입변환을 통해 문자열이된다.  
프로퍼티를 중복선언하면 값을 덮어쓴다.

### 메서드
함수는 값으로 취급할 수 있으므로 프로퍼티 값으로 사용 가능하다.  
프로퍼티값이 함수인 경우 일반 함수와 구분을 위해 메서드라고 부른다
메서드는 객체에 묶여있는 함수다.  

### 프로퍼티 접근
- 마침표 프로퍼티 접근연산자를 사용하는 마침표 표기법
- 대괄호 프로퍼티 접근연산자를 사용하는 대괄호 표기법

프로퍼티 키가 식별자 네이밍 규칙을 준수하고있다면 두방법 모두 사용가능하다.  
준수하지 않았다면 반드시 대괄호 표기법을 사용해야한다.
대괄호 표기법 사용시 프로퍼티 키는 반드시 따옴표로 감싸야 한다. 객체내에 존재하지않는 프로퍼티를 참조시 undefined를 반환한다.

- 프로퍼티 갱신: 이미 존재하는 프로퍼티 키에 값을 할당하면 갱신된다.  
- 프로퍼티 동적생성: 존재하지 않는 프로퍼티 값을 할당하면 동적생성되어 값이 할당된다.  
- 프로퍼티 삭제: delete연산자를 사용하여 객체의 프로퍼티를 삭제한다 = > 존재하지 않는 프로퍼티를 삭제해도 에러없이 무시된다.

### ES6에 추가된 객체 리터럴 확장기능
- 프로퍼티 축약표현  
	객체 리터럴의 프로퍼티의 값이 식별자 일 때, 프로퍼티키를 생략하면 식별자이름이 프로퍼티 키가 된다.  
- 계산된 프로퍼티 이름  
	ES6에선 객체 리털럴 내부에서도 계산된 프로퍼티 이름으로 동적 생성 할 수있다.  
    - 계산된 프로퍼티 : 문자열 또는 문자열로 타입변환 할 수 있는 표현식을 사용해 프로퍼티키를 동동 생성하는 것 반드시 대괄호로 묶어야한다.
- 메서드 축약 표현  
	메서드 정의시 function키워드를 생략한 축약표현을 사용할 수 있다.  
	단, 축약표현으로 만들어진 메서드와 그렇지 않은 메서드는 다르게 동작한다.  

### 원시값과 객체의 비교
JS의 데이터 타입은 크게 원시타입과 객체 타입이 있다.  
원시타입은 변경 불가능한 값, 객체 타입은 변경 가능한 값이다.  
원시값을 변수에 할당하면 변수에는 실제값이 저장된다.  
객체를 변수에 할당하면 참조값이 저장된다.  
원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달된다. (값에 의한 전달)  
객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다. (참조에 의한 전달)  

### 원시값
변경 불가능한 값  

한번 생성된 원시값은 읽기전용값으로 변경할수없다. 재할당이 금지된 것이 아니다.  
원시값은 어떤일이 있어도 불변하므로 데이터의 신뢰성을 보장한다.  
원시값은 변경 불가능하므로 원시값을 재할당하면 새 메모리 공간에 재할당 값을 저장후 변수가 참조하는 메모리 주소를 변경한다.  

### 문자열과 불변성
자바스크립트는 다른 언어와 다르게 개발자 편의를 위해 원시타입인 문자열 타입을 제공한다.  
이것은 문자열이 생성된 뒤 변경할 수 없음을 이야기한다.  
문자열은 유사 배열 객체이며 이터러블이므로 배열과 유사하게 각 문자에 접근할 수있다.  
  - 유사배열 객체 : 배열처럼 인덱스로 프로퍼티 값에 접근 할 수 있고 length프로퍼티를 갖는 객체 for문으로 순회도 가능하다.

변수에 새 문자열을 재할당 하는 것은 기존 문자열을 변경하는 것이 아니라 새 문자열을 할당하는것이기 때문에 가능하다. 
변수에 원시값을 갖는 변수를 할당하면 원시값이 복사되어 전달 된다. (값에 의한 전달)  
값은 메모리 공간에 저장되어있고 식별자는 메모리 주소를 기억한다.
두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이므로 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.  

### 객체
객체는 원시값과 달리 확보해야할 메모리의 크기를 사전에 정할 수 없으므로 객체는 원시값과 다른 방법으로 동작하도록 설계되었다.  

<!-- JS는 클래스없이 객체를 생성할 수 있으며 객체가 생성된 이후에도 동적으로 프로퍼티와 메서드를 추가할 수 있다 이는 매우 편하지만 이론적으로 클래스 기반 객체지향 프로그래밍 언어보다 접근 비용이 더많이 드는 비효율적 방식이다. -->


### 변경 가능한 값
객체타입의 값은 변경 가능한 값이다.  
객체를 할당한 변수가 기억하는 메모리주소를 통해 메모리 공간에 접근하면 참조값에 접근 할 수 있다.  
객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장되어있다. 이값을 참조값이라고 한다 변수는 이 참조값을 통해 객체에 접근한다.  
객체는 재할당 없이 객체를 직접 변경할 수 있기 때문에 재할당 없이 프로퍼티의 추가 삭제 갱신이 가능하다.  

객체를 변경할때마다 새 메모리에 값을 생성한다면 명확하고 신뢰성이 보장되지만 객체의 크기가 매우 클 수도 있고 원시값처럼 크기가 일정하지도 않으며 프로퍼티의 값이 객체일수도 있어서 복사해서 생성하는 비용이 더 크므로 메모리의 효율적 소바가 어렵고 성능이 나빠진다.
따라서 메모리의 효율적 사용을 위해 객체는 변경 가능한 값으로 되어있다.  
이러한 구조엔 부작용이 있는데 여러가지 식별자가 하나의 객체를 공유할 수 있다는것이다.  

### 참조에 의한 전달
원본 객체를 복사하며 원본 변수와 사본 변수는 저장된 메모리 주소는 다르지만 동일한 참조값을 갖는다. 이것은 두개의 식별자가 하나의 객체를 공유한다는것이다.  
원본이나 사본중 어느 하나를 변경하면 서로 영향을 받는다.  
