# 2021.09.04 [8일차]

오늘은 정기 테스트 오답노트와 어제 받은 HTML 연습문제 그리고 코딩테스트 연습문제 풀이를 진행했다.  
HTML 오답노트를 통해 문제가 요구하는것이 무엇인지 자세하게 살펴봐야겠다는 생각을 했다.
특히 오답 중 `alt="Google"`가 정답인 문제가 있었는데, 이것을 내가 `alt = "Google"`이라고 적어 문법오류로 틀린 문제가 있었다.  
HTML 연습문제는 생각했던것 보다 난이도가 높지는 않았다.  
강의내용을 알고 있다면 충분히 쉽게 풀수 있는 난이도 였고 다 푼 문제는 본 문서에 동봉된 HTML연습문제 파일에 각 번호별로 풀어놓았다.  
문제는 코딩테스트부분이였는데 알고리즘을 손에서 놓고있던게 꽤 오래된것도 있고 JS를 통한 입출력을 해본적이 없어 문제를 푸는 기본환경을 마련하는데 꽤나 시간이 오래걸렸다.  
오늘은 한문제 밖에 풀지 못했지만 내일 이어 풀어서 나머지 문제를 풀어보아야겠다.

## 공부한 내용

- HTML유효성 검사에 대해 알게되었다. 이 검사를 통해 내 코드가 웹 표준성을 지키고 있는지 링크가 꺠지지는 않았는지 등을 검사해 올바른 HTML파일을 만들었는지 알수있다.
- `<meter>`에 대해 알게되었다 이 태그는 특정 범위내의 스칼라 값, 또는 백분율을 나타낸다. 사용하는 속성으로 `min`, `max`, `low`, `high`, `value`, `optium`, `form`이 있다.
- 코딩테스트 문제를 통해 JavaScript의 입출력에 대해 공부했다.
- 출력을 할때 `console.log`를 통해 출력하고 입력방법엔 filesystem방식솨 readline방식이 있다.
- readline방법을 통해 입력시 콜백을 통해 값을 입력받고 처리한다.  
이떄 readline모듈을 close해주지 않으면 프로그램이 종료될 수 없다.
- 문자열 split을 통해 입력이 들어온 문자열을 사용할 수 있는 형태로 가공하는데 이때 정규표현식을 통해 데이터를 가공할 수 있다.
- 정규표현식은 두개의 /안에 지정된 표현식을 넣어 문자열을 분리할 수 있다.  
- split으로 분리된 문자열은 자동으로 배열형식으로 변수에 저장된다.  
- 이때 공란으로 분리된 문자열은 filter함수를 이용해 제거할 수 있다.
- 아직 풀지못한 아재개그 문제는 DFS(깊이 탐색)을 요구하는 문제이다.  
- DFS는 시작점부터 다음분기로 넘어가기전 해당 분기의 하위요소를 모두 검사하고 넘어가는 알고리즘이다. 보통 재귀함수를 스택과 재귀함수를 이용해서 만든다.  
- DFS알고리즘 제작시 이미 지나간 노드는 방문을 했다고 표시를 해야한다. 그렇지 않으면 무한루프에 빠질 수 있다.


### 강의 학습 현황

\> 오늘은 강의를 듣지 않고 지난 문제의 복습과 연습문제 그리고 코딩테스트 문제를 풀어보며 알고리즘 공부를 했다.  
특히 알고리즘 문제를 풀면서 그간 손대지 않고있던 JavaScript의 여러 요소와 알고리즘 구현에 시간을 많이 쓰고 다시 찾아보며 공부를 했다.

## HTML 유효성검사

사이트의 코드를 검사하여 필요한 변경사항을 모니터링 하고 문서에 유해한 오류를 디버깅합니다.  
웹 접근성을 준수할 수 있게 도와주고 스크립트의 보안 허점을 찾는데도 도움을 줍니다.
위의 이유 외에도 HTML유효성 검사를 통해 웹사이트의 품질을 향상시킬수 있는 요소는 많습니다.

## meter

`<meter>`는 특정범위내의 스칼라값, 또는 백분율 값을 나타내는 요소입니다.  
`<meter>`의 생김새는 게이지 바 처럼 생겼습니다.
사용하는 속성으론  `min`, `max`, `low`, `high`, `value`, `optium`, `form`이 있습니다.

## 자바스크립트 입출력

자바 스크립트에는 C언어나 JAVA와 같은 편리하게 입출력 할수 있는 방법이 없다.  
따라서 fs모듈로 stdin(standard input)을 입력 받거나 readline모듈을 사용해 입력을 받아야한다.

```javascript
// JS에서 readline을 통해 입력하기
// readline 모듈을변수에 담는다
const readline = require('readline');

//readline의 createInterface함수를 통해 rl에 input, output을 담는다
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

//line을 통해 입력받는다
rl.on('line', function(line) {

//입력이 끝나면 close
  rl.close();
}).on("close", function() {
  process.exit(); //close하면 프로세스를 종료한다.
});
```

## split

문자열은 `split()`함수를 통해 구분자를 기준으로 분리하여 배열에 담을 수 있다.
```javascript
const str = 'hello';
const splitStr = str.split('');
console.log(splitStr); // ['h','e','l','l','o']
```

## filter

배열에서 `filter()`를 통해 filter안의 요소를 제거한 배열을 리턴할 수 있다.
```javascript
const arr = ['','a','b','c'];
const arr2 = arr.filter('');
console.log(arr2); // ['a','b','c']
```

## DFS 알고리즘

DFS는 그래프 전체를 탐색하는 방법으로 시작점에서 다음 분기로 넘어가기 전에 해당 분기의 하위 요소를 모두 탐색하는 알고리즘을 말한다.  
스택이나 재귀함수를 이용해 DFS알고리즘을 구현할 수 있는데 보통 컴퓨터의 자료구조가 스택의 모양을 띄고 있어 재귀함수로 만드는 경우가 많다.  
구현시 주의할 점으론 이미 지나간 노드에 대해 방문 여부를 체크해야한다는것이다. 이를 하지 않으면 무한 루프에 빠질 수 있다.