# 2021.09.12 [16일차]

grid강의가 아직 열리지 않아 오늘은 CSS의 폰트에서 transition까지 복습했다.  
그 후에 어제 풀던 코딩테스트 문제를 마저 풀기시작했다.  
코딩 테스트 문제를 푸는 문제는 되게 쉬워보였는데 막상 풀려고 시도하니 시간을 엄청나게 잡아먹었다.  
특히 문제가 요구하는 규칙성을 찾는데 시간을 많이 할애 했고 6번문제의 경우 이중배열을 만드는데 시간을 많이 쓰게되었다.  
4, 5번과 다르게 6번의 경우 최단경로는 찾는 너비탐색을 요구하는데 너비탐색에 대해 이해는 했지만 이것을 막상 코드로 만드는데 시간을 많이 소모했다.  
아직 풀지 못했지만 작성한 코드는 업로드 하고 마저 풀어서 제출해야겠다.


## 공부한 내용

- HTML, CSS관련 내용은 본 문서의 index.html과 main.css를 통해 확인할 수 있다.  
[복습 HTML 바로가기](https://goofy-pike-2843c1.netlify.app/2021.09.12%5B16%EC%9D%BC%EC%B0%A8%5D/)
- Array.length를 통해 배열의 길이를 구할 수 있다.
- JavaScript에서 지정되지 않은 배열값은 undefined가 된다.
- 배열은 `push()`함수를 통해 값을 추가할 수 있다.
- 문자열을 `split()`, `reverse()`, `join()`함수를 사용하면 역순 출력 할 수 있다.
- 정규 표현식을 사용하여 입력값에서 불필요한 요소를 삭제할 수 있다.
- `filter()`함수를 통해 정규표현식으로 걸러낸 배열중 빈배열을 삭제할 수 있다.
- 배열에 배열을 넣음으로써 2차원 배열을 만들 수 있다.
- 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS)를 통해 미로를 찾을수 있다.


## 학습 결과물

오늘의 학습결과물은 TIL 최상위 파일의 '학습 결과물 살펴보기 링크에 추가되었습니다.

### 강의 학습 현황

\> CSS강의 '폰트관련 속성', '단위와 값', '박스모델', '색상과 배경', 'transform', 'transition' 복습및 실습파일 구성, 코딩테스트 연습문제2 4~5풀이, 6은 풀고있다.


## 코딩 테스트 연습문제 4번

전광판에 글자요소가 흐른다.  
이 문제에서 글자요소는 마지막 글자가 전광판을 지나야만 다시 글자의 첫요소가 나온다.  
1초에 글자가 하나씩 지나가기 떄문에 전광판을 모든 글자가 전광판을 완전히 지나가기 위해선  
```
전광판의 길이 + 글자의 길이 = 글자가 전광판을 완전히 한바퀴 도는시간
```
의 공식이 나온다.  
따라서 시간이 얼마나 주어지든간에 전광판의 길이 + 문자열의 길이로 전광판 노출시간을 나누어 나머지 값을 구하면 그 값이 문자열이 새로 배치되는 시간인것이다.
전광판의 길이가 5, 주어진 문자열이 SNOWBALL, 전광판의 노출시간이 15라면
```
15 % (5 + 8) = 2
```
이므로 전광판에 출력되는 글자는 전광판을 2초동안 킨것과 결과가 같다는것이다.

그렇다면 나머지 값이 전광판의 길이보다 작을땐 다음과 같이 출력한다.
```javascript
for (let i = 0; i < 전광판의 길이 - 나머지 값; i++)
  answer.push(".");
for (let i = 0; i < 나머지값; i++)
  answer.push(str[i]);
```

하지만 전광판의 길이보다 나머지 값이 크다면 전광판을 글자가 가득채울수도, 뒤쪽이 빌 수도 있기때문에 다음과 같이 써야한다.
```javascript
 for (let i = 0; i < leng; i++) {
  let idxStart = 나머지 값-전광판의 길이;

  if(str[idxStart+i] == undefined || str[idxStart+i] == ' ')
    answer.push(".");
  else
    answer.push(str[idxStart+i]);
}
```
예제 문제인 SNOWBALL을 기준으로 볼때 전광판의 노출시간이 10이라면 10 % 13 = 10 이므로  
전광판의 길이인 5보다 나머지값 10이 크다.

이때 '나머지 값-전광판의 길이'를 하면 전광판의 맨 앞칸에 들어갈 글자의 인덱스가 나온다.

0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 
--|--|--|--|--|--|--|--
S |N | O|W|B|A|L|L

따라서 전광판의 첫자리를 SNOWBALL의 5번 인덱스인 A부터 채우면 ALL..이 나온다.  
이는 예제문제의 예시에 알맞기떄문에 맞는 값이다.  
이때 반복문이 문자열의 8번 9번 인덱스를 참조 하게 되면 undefined를 출력하는데, 조건문을 통해 이땐 .을 찍도록 하면 문제를 해결할 수 있다.



## 코딩테스트 연습문제 5번

5번 문제는 주어진 값을 구분자로 나눈뒤 역순으로 다시 출력하는것이다.  
이때 공백으로 구분자로 나누어진 단어는 배열로 나누어 출력해야한다.  

이 문제는 상당히 쉬운문제였다.  
JavaScript에서 문자열에 `split()`함수를 사용하면 괄호안의 구분자를 통해 글을 나누어 배열로 리턴한다.  
우리는 이때 ',', '.', '?', '!', ' '이 다섯가지 구분자를 통해 문자를 구분하는데 `split()`함수에 여러 구분자를 넣기 위해서 정규표현식을 사용한다.  
정규표현식 `/\,|\.|\?|\!|\ /`를 통해 다섯가지 구분자 중 어느것이라도 걸리면 문자열을 나누어 배열로 리턴한다.  
주어진예제인 Hello World?!를 다음 정규표현식을 통해 split하면 다음과 같은 배열을 출력한다.  
['Hello', 'World', '', '']   
뒤의 비어있는 배열은 연속된 두개의 구분자 ?!로 인해 생긴것이므로 우리는 이 빈 배열이 필요없다.  
이때 `filter()`함수를 사용하여 원하는 값만 리턴 받으면된다.  
우리는 빈 배열이 필요없으므로
```javascript
let arr = 입력문자열.split(/\,|\.|\?|\!|\ /).filter(el=>el!='');
```
을 통해 ['Hello', 'World']를 가질수 있게된다.  
이렇게 추출한 문자열은 다시한번
```javascript
for (let i = 0; i < arr.length; i++) {
  arr[i] = arr[i].split('').reverse().join('');
}
```
다음과 같은 코드를 사용하여 역순 출력할 수 있다.

## 코딩테스트 6번

이 문제는 아직 완전히 풀지 못했다.  
이 문제는 이중 배열문을 입력받아 이중배열로 만들고, 그 이중배열애서 1들이 0까지의 가장 가까운 거리를 측정하여 다시 이중배열로 출력하는 문제이다.  
이중 배열의 제작은 앞서본 5번 문제와 같이
```javascript
arr1 = 입력문자열.split(/\]\,\ \[/);
```
을 통해 한줄씩 담아낸뒤 반복문을 통해
```javascript
arr2.push(arr1[i].split(/\D/).filter(el=>el!=''));
```
로 이중 배열을 만들수 있다.

그렇게 얻어낸 배열은 너비 우선 탐색을 통해 최단 거리를 찾아 낼 수 있는데 이는 노드가 한번에 모든 노드를 검사하여 가장빠른 값을 출력하는것이다.

아직 BFS는 코드를 구현하지 못했다.