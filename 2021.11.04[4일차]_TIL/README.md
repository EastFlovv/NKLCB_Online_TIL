# 2021.11.04 [4일차]

오늘은 러버덕을 통해 조원들과 6 ~ 11강의 내용을 복습하고 서로 궁금했던 점을 해결했다.  
서로 아는것을 설명해주는 과정에서 기존에 두루뭉실하게 알고 있던 개념들이 머리속에 확실하게 잡히게 되었고 왜 그렇게 되는지 또한 고심해보니 결국 앞서 배운 데이터 타입이나 CS에 의한 저장 구조에 따른 한계등 우리가 궁금해하고 헷깔려하는 요소들이 상당히 기초적인 부분에서 비롯된다는것을 알게 되었다.  
기초 공부를 소홀히 하면 이런 JS의 여러 현상이 왜 일어나는지 알 수 없고 이해를 떨어트린다는것을 알게 되었다. 기초 공부를 소홀히 해서는 안되겠다고 생각했다.


## 공부한 내용

- 값을 결정하는 평가의 정의에 대해 알게되었다.
- 원시타입과 객체타입의 차이점과 그 구조적 차이에 대해 알게 되었다.  
- 코딩 테스트에서의 제어문과 실제 프로젝트에서의 제어문 사용의 차이를 배웠다. 결론은 두 방법 모두 잘 쓸줄 알아야 한다는것
- 객체의 얕은 복사와 깊은 복사에 대해 이해하게 되었다. 앞서 본 데이터 타입의 저장 구조에 따라 생기는 차이이다.

## 학습 결과물
학습 결과물은 같이 포함된 파일에 동봉되었으며 각 TIL의 목록별 소제목에 링크가 달려있다.

### 강의 학습 현황

\> 러버덕 (얕은복사, 깊은복사), 강의님 질의응답, 코테 문제풀이 3문, 스터디 가입

## 러버덕

### 평가란?
프로그래밍에선 값을 계산하지 않고 평가한다. 왜냐하면 평가 값이 수가 아닐 수 있기 때문이다. 평가는 실행이라는 개념의 부분 집합이다.  
평가는 실행이지만, 실행이 평가는 아니다.  
실행된 문으로 값이 생성되지 않는다면 실행이고, 값이 만들어졌다면 평가이다.  

### 데이터 타입
변수는 자신의 데이터 타입을 어떻게 구분하는가? : 할당시 변수가 데이터 타입에 관한 정보를 가진다.
JS의 변수는 선언이 아닌 할당에 의한 타입이 결정됨(타입 추론)

### 제어문 : for문
for문은 가독성이 떨어지고 실수 할 가능성이 크다. 현업에서는 fiter, for...in, for...of와 같은 고차함수를 사용한다.  
이는 현업이 주로 선언형(함수형)패러다임을 따르고 있기 떄문에 명령형 구문인 for문을 좋아하지 않기 때문
그러나 알고리즘 테스트를 위해선 for문을 사용해야 할 일이 많으므로 두가지 방법 모두 사용법을 잘 익히고 있어야 한다. (+ for문은 고차함수들보다 월등히 빠르다)

### 객체의 얕은 복사와 깊은 복사
팀원중 한명이 이 개념을 질문해 같이 고민해주고 설명해주면서 그 차이를 확연히 알게 되었다.  
원시값은 변수가 값이 실제로 저장된 주소를 가리키고 있지만, 객체는 변수가 마치 포인터처럼 객체의 주소값을 담고 있는 메모리 주소를 가지고 있기때문에 얕은 복사로 가져 오는 값은 기존에 사용하던 변수의 주소값을 가져오므로 다른 같은 메모리 주소를 공유하게 되는것이다.  
반면 깊은 복사는 내부의 객체까지 복사하므로 그런 일이 생기지 않는다.
이는 강사님이 설명해주신 데이터 타입의 불변성과 객체타입의 이중할당과 연관이 있다.  
컴퓨터가 나온지 얼마 되지 않았을땐 다른 타입보다 크기가 큰 객체를 연속해서 만드는것이 메모리 사용량에 상당한 부하를 줘 객체는 불변성을 갖추지 못한 타입이 되었다.  
그러나 이러한 저장 방식이 모던한 개발에서는 안정성을 해치고 메모리의 공간 또한 크게 늘어나면서 모던한 개발과정에선 기존 객체를 복사해 새 값을 추가하는 방법을 사용해 안정성을 확보했다.

## 프로그래머스 문제 풀이
머리식힐겸 1단계 2문제를 풀고 2단계 한문제를 풀었다.
### 숫자 문자열과 영단어
문자열에서 문자를 추출하여 영어로 바꿔 수로 된 string을 반환하는 문제
```js
function solution(s) {
  let answer = 0;
  // 다른 사람들 코드를 보니 이부분에 정규 표현식을 넣었다.
  const arr = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']; 

  let str = '';
  // 타인의 코드는 정규 표현식을 통해 한번에 모든 문자열을 바꾼다.
  // 나는 모든 글자열을 탐색해야한다
  for(let i = 0; i < s.length; i++){
      if(Number(s[i]) <= 9) answer = answer*10 + Number(s[i]);
      else str += s[i];

      if(arr.includes(str)) {
          answer = answer * 10 + arr.indexOf(str);
          str = '';
      }
  }

  return answer;
}
```
### 신규 아이디 추천
정규표현식과 String메서드를 이용해 주어진 조건에 맞추어 문자열을 만드는 문제이다.
```js
function solution(new_id) {
  let answer = '';
  let reg = /\w|.|-/;
  // 1, 2단계
  let str = new_id.toLowerCase().split('').filter(el => el.match(reg)).join('');
  // console.log(str);
  // 3단계
  reg = /.{2}/;
  while(1){
      str = str.replace(reg, '.');
      if(!str.match(reg)) break;
  }
  // console.log(str);
  // 4단계
  reg = /^.|.$/;
  while(1){
      str = str.replace(reg, '');
      if(!str.match(reg)) break;
  }
  // console.log(str);
  // 5단계
  if(!str) str += 'a';
  // console.log(str);
  // 6단계
  reg = /.$/;
  if(str.length > 15) str = str.substring(0, 15).replace(reg, '');
  // console.log(str);
  // 7단계
  while(str.length < 3) str += str[str.length-1];
  // console.log(str);
  answer = str;
  return answer;
}
```

### 이진 변환 반복하기
이진수에서 0을 모두 제거하고 남은 1을 십진수로 변환하고 그 십진수의 이진수를 다시 만들어 1이 될때까지 반복한 뒤 반복 횟수와 지운 0의 갯수를 반환하는 문제이다.
```js
function solution(s) {
  // [이진변환 횟수, 제거된 0의 갯수]
  const answer = [0, 0];

  let str = s;
  // 마지막은 항상 1이다.
  while (str.length > 1) {
    // 1의 갯수 초기화
    let countOne = 0;
    // 문자열은 이터레이터 for... of
    for (const el of str) {
      // 1의 갯수 세기
      if (el == '1') countOne++;
    }
    // 전체 길이에서 1의 갯수만큼 뺀 값 => 0의 갯수
    answer[1] += str.length - countOne;
    // 1의 갯수를 이진수로 변환하여 재할당
    str = countOne.toString(2)
    // 변환 횟수 증가
    answer[0]++;
  }
  return answer;
}
```